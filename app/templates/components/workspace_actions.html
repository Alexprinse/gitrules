<!-- Right Panel: Add tools -->
<div class="workspace-actions" style="height: 100%; display: flex; flex-direction: column;">
    <div class="p-4 flex-1 overflow-y-auto">
        <h3 class="text-lg font-black text-black mb-4">Add tools</h3>
        
        <!-- QuickAction Section - Search Bar -->
        <div class="mb-4">
            <h4 class="text-sm font-bold text-black mb-2">Quick Action</h4>
            <div class="search-container">
                <input 
                    type="text" 
                    class="search-input"
                    placeholder="Search actions..."
                    onkeyup="searchActions(this.value)"
                />
                <div class="search-results" id="search-results" style="display: none;"></div>
            </div>
        </div>

        <!-- Toggle Menu Buttons -->
        <div class="mb-4">
            <h4 class="text-sm font-bold text-black mb-2">Actions</h4>
            
            <!-- MCPs Button with Expand -->
            <div class="menu-item mb-2">
                <button 
                    class="menu-button expandable"
                    data-theme="yellow"
                    onclick="toggleMenuButton(this, 'mcps')"
                >
                    <span class="menu-button-plus">+</span>
                    <span class="menu-button-text">MCPs</span>
                    <span class="menu-button-expand">▼</span>
                </button>
                <div class="menu-dropdown" id="dropdown-mcps" style="display: none;">
                    <div id="mcps-list" class="p-2">
                        {% for mcp in mcps %}
                        <div class="dropdown-item" onclick="toggleDropdownItem(this, '{{ mcp.name }}', 'mcps')">
                            <span class="dropdown-item-icon">+</span>
                            <span>{{ mcp.name }}</span>
                        </div>
                        {% endfor %}
                        {% if not mcps %}
                        <div class="text-xs text-gray-500">No MCPs available</div>
                        {% endif %}
                    </div>
                </div>
            </div>

            <!-- Rules Button with Expand -->
            <div class="menu-item mb-2">
                <button 
                    class="menu-button expandable"
                    data-theme="pink"
                    onclick="toggleMenuButton(this, 'rules')"
                >
                    <span class="menu-button-plus">+</span>
                    <span class="menu-button-text">Rules</span>
                    <span class="menu-button-expand">▼</span>
                </button>
                <div class="menu-dropdown" id="dropdown-rules" style="display: none;">
                    <div id="rules-list" class="p-2">
                        {% for rule in rules %}
                        <div class="dropdown-item" onclick="toggleDropdownItem(this, '{{ rule.slug or rule.name }}', 'rules')">
                            <span class="dropdown-item-icon">+</span>
                            <span>{{ rule.display_name or rule.name }}</span>
                        </div>
                        {% endfor %}
                        {% if not rules %}
                        <div class="text-xs text-gray-500">No rules available</div>
                        {% endif %}
                    </div>
                </div>
            </div>

            <!-- Agents Button with Expand -->
            <div class="menu-item mb-2">
                <button 
                    class="menu-button expandable"
                    data-theme="blue"
                    onclick="toggleMenuButton(this, 'agents')"
                >
                    <span class="menu-button-plus">+</span>
                    <span class="menu-button-text">Agents</span>
                    <span class="menu-button-expand">▼</span>
                </button>
                <div class="menu-dropdown" id="dropdown-agents" style="display: none;">
                    <div id="agents-list" class="p-2">
                        {% for agent in agents %}
                        <div class="dropdown-item" onclick="toggleDropdownItem(this, '{{ agent.slug or agent.name }}', 'agents')">
                            <span class="dropdown-item-icon">+</span>
                            <span>{{ agent.display_name or agent.name }}</span>
                        </div>
                        {% endfor %}
                        {% if not agents %}
                        <div class="text-xs text-gray-500">No agents available</div>
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* Workspace actions sidebar */
.workspace-actions {
    background: white;
    border-left: 2px solid black;
    min-height: 100%;
    height: 100%;
}

/* Search Container */
.search-container {
    position: relative;
}

.search-input {
    width: 100%;
    padding: 8px 12px;
    border: 2px solid black;
    font-size: 14px;
    background: white;
    box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    transition: all 150ms ease;
}

.search-input:focus {
    outline: none;
    box-shadow: 3px 3px 0px 0px rgba(0,0,0,1);
    transform: translate(-1px, -1px);
}

.search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    margin-top: 4px;
    background: white;
    border: 2px solid black;
    box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    max-height: 200px;
    overflow-y: auto;
    z-index: 10;
}

.search-result-item {
    padding: 6px 10px;
    font-size: 13px;
    cursor: pointer;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    align-items: center;
    gap: 6px;
}

.search-result-item:last-child {
    border-bottom: none;
}

.search-result-item:hover {
    background: #f3f4f6;
}

.search-result-type {
    font-size: 10px;
    font-weight: bold;
    padding: 2px 4px;
    border: 1px solid black;
    background: #f3f4f6;
}

/* Menu Button Base Style */
.menu-button {
    width: 100%;
    display: flex;
    align-items: center;
    background: white;
    border: 2px solid black;
    padding: 0;
    font-weight: bold;
    font-size: 14px;
    cursor: pointer;
    transition: all 150ms ease;
    box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    position: relative;
    overflow: hidden;
}

/* Plus icon area */
.menu-button-plus {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    font-weight: bold;
    border-right: 2px solid black;
    flex-shrink: 0;
}

/* Text area */
.menu-button-text {
    flex: 1;
    padding: 0 12px;
    color: black;
    text-align: left;
}

/* Expand arrow */
.menu-button-expand {
    padding: 0 12px;
    font-size: 12px;
    color: black;
    transition: transform 150ms ease;
}

/* Theme colors for plus area (default state) */
.menu-button[data-theme="yellow"] .menu-button-plus {
    background: #FDE047;
}

.menu-button[data-theme="pink"] .menu-button-plus {
    background: #F472B6;
}

.menu-button[data-theme="blue"] .menu-button-plus {
    background: #22D3EE;
}

/* Toggled state - color inversion (color moves to text area) */
.menu-button.toggled[data-theme="yellow"] {
    background: #FDE047;
}

.menu-button.toggled[data-theme="yellow"] .menu-button-plus {
    background: white;
}

.menu-button.toggled[data-theme="pink"] {
    background: #F472B6;
}

.menu-button.toggled[data-theme="pink"] .menu-button-plus {
    background: white;
}

.menu-button.toggled[data-theme="blue"] {
    background: #22D3EE;
}

.menu-button.toggled[data-theme="blue"] .menu-button-plus {
    background: white;
}

/* Text always stays black */
.menu-button .menu-button-text,
.menu-button.toggled .menu-button-text {
    color: black;
}

/* Expanded state */
.menu-button.expanded .menu-button-expand {
    transform: rotate(180deg);
}

/* Hover effect */
.menu-button:hover {
    box-shadow: 3px 3px 0px 0px rgba(0,0,0,1);
    transform: translate(-1px, -1px);
}

/* Active/pressed effect */
.menu-button:active {
    box-shadow: 1px 1px 0px 0px rgba(0,0,0,1);
    transform: translate(1px, 1px);
}

/* Dropdown container */
.menu-dropdown {
    background: white;
    border: 2px solid black;
    border-top: none;
    margin-top: -2px;
    box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
}

/* List items in dropdown */
.dropdown-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 8px;
    font-size: 12px;
    cursor: pointer;
    transition: background 100ms ease;
}

.dropdown-item:hover {
    background: #f3f4f6;
}

.dropdown-item.active {
    background: #e5e7eb;
    font-weight: bold;
}

.dropdown-item-icon {
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    border: 1px solid black;
}

.dropdown-item.active .dropdown-item-icon {
    background: black;
    color: white;
}
</style>

<script>
// Initialize actions data from server-side rendering
const serverActions = {
    agents: {{ agents | tojson | safe }},
    rules: {{ rules | tojson | safe }},
    mcps: {{ mcps | tojson | safe }}
};

// Track loaded data
let loadedData = {};

// Search functionality - initialize with server data
let allActions = [
    ...(serverActions.mcps || []).map(item => ({...item, type: 'MCP'})),
    ...(serverActions.rules || []).map(item => ({...item, type: 'Rule'})),
    ...(serverActions.agents || []).map(item => ({...item, type: 'Agent'}))
];
let searchTimeout = null;

// Initialize search data - no longer needed as data comes from server
// The allActions array is already initialized with server data above

// Search actions
function searchActions(query) {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        const resultsContainer = document.getElementById('search-results');
        
        if (!query || query.trim() === '') {
            resultsContainer.style.display = 'none';
            return;
        }
        
        const searchTerm = query.toLowerCase();
        const filtered = allActions.filter(action => {
            const displayName = action.display_name || action.name;
            return displayName.toLowerCase().includes(searchTerm);
        });
        
        if (filtered.length > 0) {
            resultsContainer.innerHTML = filtered.map(action => {
                const itemId = action.slug || action.name;
                const displayName = action.display_name || action.name;
                return `
                    <div class="search-result-item" onclick="selectSearchResult('${itemId}', '${action.type}')">
                        <span class="search-result-type">${action.type}</span>
                        <span>${displayName}</span>
                    </div>
                `;
            }).join('');
            resultsContainer.style.display = 'block';
        } else {
            resultsContainer.innerHTML = '<div class="search-result-item">No results found</div>';
            resultsContainer.style.display = 'block';
        }
    }, 200);
}

// Select search result
async function selectSearchResult(name, type) {
    const resultsContainer = document.getElementById('search-results');
    const searchInput = document.querySelector('.search-input');
    
    // Clear search
    searchInput.value = '';
    resultsContainer.style.display = 'none';
    
    // Install the selected action
    if (type === 'MCP') {
        await installMCP(name);
    } else if (type === 'Rule') {
        await installRule(name);
    } else if (type === 'Agent') {
        await installAgent(name);
    }
}

// Restore action states from unified state
function restoreActionStates() {
    const state = window.workspaceManager?.getState();
    if (!state) return;
    
    // Restore MCPs state
    if (state.isActionCategoryActive('mcps')) {
        const button = document.querySelector('[data-theme="yellow"]');
        const dropdown = document.getElementById('dropdown-mcps');
        if (button && dropdown) {
            button.classList.add('toggled');
            button.classList.add('expanded');
            dropdown.style.display = 'block';
            if (!loadedData['mcps']) {
                loadDropdownData('mcps');
                loadedData['mcps'] = true;
            }
        }
    }
    
    // Restore Rules state
    if (state.isActionCategoryActive('rules')) {
        const button = document.querySelector('[data-theme="pink"]');
        const dropdown = document.getElementById('dropdown-rules');
        if (button && dropdown) {
            button.classList.add('toggled');
            button.classList.add('expanded');
            dropdown.style.display = 'block';
            if (!loadedData['rules']) {
                loadDropdownData('rules');
                loadedData['rules'] = true;
            }
        }
    }
    
    // Restore Agents state
    if (state.isActionCategoryActive('agents')) {
        const button = document.querySelector('[data-theme="blue"]');
        const dropdown = document.getElementById('dropdown-agents');
        if (button && dropdown) {
            button.classList.add('toggled');
            button.classList.add('expanded');
            dropdown.style.display = 'block';
            if (!loadedData['agents']) {
                loadDropdownData('agents');
                loadedData['agents'] = true;
            }
        }
    }
}

// Export for global use
window.restoreActionStates = restoreActionStates;
window.loadDropdownData = loadDropdownData;

// Initialize on load
document.addEventListener('DOMContentLoaded', function() {
    // No need to call initSearchData - data is already loaded from server
    // Wait a bit for workspace manager to initialize
    setTimeout(() => {
        restoreActionStates();
    }, 100);
});

// Toggle menu button - handles both toggle and expand together
function toggleMenuButton(button, type) {
    const state = window.workspaceManager?.getState();
    if (!state) return;
    
    const isToggled = state.isActionCategoryActive(type);
    const dropdown = document.getElementById(`dropdown-${type}`);
    
    // Toggle the button state in unified state
    state.toggleActionCategory(type);
    
    // Update UI based on new state
    if (!state.isActionCategoryActive(type)) {
        button.classList.remove('toggled');
        button.classList.remove('expanded');
        dropdown.style.display = 'none';
        // Remove from context
        removeFromContext(type);
    } else {
        button.classList.add('toggled');
        button.classList.add('expanded');
        dropdown.style.display = 'block';
        // Insert into context
        insertIntoContext(type);
        // Load data if needed
        if (!loadedData[type]) {
            loadDropdownData(type);
            loadedData[type] = true;
        }
    }
    
    // Save state to localStorage
    window.workspaceManager.saveState(window.workspaceManager.currentContextId);
}

// Insert action into context
async function insertIntoContext(type) {
    // No longer auto-install default items
    // Users should explicitly choose which items they want
    // This function is kept for potential future use
}

// Remove action from context
async function removeFromContext(type) {
    if (window.workspaceManager) {
        const state = window.workspaceManager.getState();
        if (!state) return;
        
        if (type === 'agents') {
            // Remove agent files - use proper deleteFile method
            const agentFiles = Object.keys(state.files).filter(f => 
                f.startsWith('.gitrules/agents/') || f.startsWith('.claude/agents/')
            );
            agentFiles.forEach(file => {
                // Use workspaceManager.deleteFile which triggers render
                window.workspaceManager.deleteFile(file);
            });
        } else if (type === 'mcps') {
            // Remove MCP config entirely when toggling off MCPs category
            if (state.files['.mcp.json']) {
                window.workspaceManager.deleteFile('.mcp.json');
            }
        } else if (type === 'rules') {
            // Remove CLAUDE.md entirely when toggling off Rules category
            // (since having an empty CLAUDE.md provides no value)
            if (state.files['CLAUDE.md']) {
                window.workspaceManager.deleteFile('CLAUDE.md');
            }
        }
        // No need to manually save/render - deleteFile handles it
    }
}

// Load dropdown data - now just updates the UI state based on what's already rendered
function loadDropdownData(type) {
    // The dropdown items are now rendered server-side with Jinja
    // This function just needs to update the UI state (active/inactive)
    const state = window.workspaceManager?.getState();
    if (!state) return;
    
    const container = document.getElementById(`${type}-list`);
    if (!container) return;
    
    // Update each dropdown item's state
    const items = container.querySelectorAll('.dropdown-item');
    items.forEach(item => {
        const itemName = item.getAttribute('data-item-id') || 
                        item.onclick.toString().match(/toggleDropdownItem\(this,\s*'([^']+)'/)?.[1];
        if (itemName) {
            const isChecked = state.isActionItemChecked(type, itemName);
            const icon = item.querySelector('.dropdown-item-icon');
            if (isChecked) {
                item.classList.add('active');
                if (icon) icon.textContent = '−';
            } else {
                item.classList.remove('active');
                if (icon) icon.textContent = '+';
            }
        }
    });
}

// Toggle individual dropdown item
function toggleDropdownItem(element, itemName, type) {
    const state = window.workspaceManager?.getState();
    if (!state) return;
    
    // Toggle in unified state
    state.toggleActionItem(type, itemName);
    const isChecked = state.isActionItemChecked(type, itemName);
    
    // Update UI
    const icon = element.querySelector('.dropdown-item-icon');
    if (isChecked) {
        element.classList.add('active');
        icon.textContent = '−';
        // Install the specific item
        if (type === 'mcps') {
            installMCP(itemName);
        } else if (type === 'rules') {
            installRule(itemName);
        } else if (type === 'agents') {
            installAgent(itemName);
        }
    } else {
        element.classList.remove('active');
        icon.textContent = '+';
        // Remove the specific item
        if (type === 'mcps') {
            removeMCP(itemName);
        } else if (type === 'rules') {
            removeRule(itemName);
        } else if (type === 'agents') {
            removeAgent(itemName);
        }
    }
    
    // Save state to localStorage
    window.workspaceManager.saveState(window.workspaceManager.currentContextId);
}

// Backend integration functions (from previous implementation)
async function installAgent(agentName) {
    try {
        const response = await fetch(`/api/actions/agent-content/${encodeURIComponent(agentName)}`);
        
        if (response.ok) {
            const result = await response.json();
            
            if (window.workspaceManager) {
                const state = window.workspaceManager.getState();
                if (state) {
                    // Store agent name to path mapping in metadata (for easier removal)
                    state.agentMappings[agentName] = result.path;
                    
                    // Mark the agent as checked in action state
                    state.setActionItemState('agents', agentName, true);
                }
                
                // Use includeFile which properly handles saving and rendering
                window.workspaceManager.includeFile(result.path, result.content);
            }
        }
    } catch (error) {
        console.error(`Error installing agent: ${error.message}`);
    }
}

async function installMCP(mcpName) {
    try {
        let currentConfig = {};
        if (window.workspaceManager && window.workspaceManager.getState()) {
            const mcpFile = window.workspaceManager.getState().files['.mcp.json'];
            if (mcpFile) {
                try {
                    currentConfig = JSON.parse(mcpFile);
                } catch (e) {
                    currentConfig = {};
                }
            }
        }
        
        const response = await fetch(`/api/actions/mcp-config/${encodeURIComponent(mcpName)}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(currentConfig)
        });
        
        if (response.ok) {
            const result = await response.json();
            
            if (window.workspaceManager) {
                const state = window.workspaceManager.getState();
                if (state && !result.was_removed) {
                    // Mark the MCP as checked in action state
                    state.setActionItemState('mcps', mcpName, true);
                } else if (state && result.was_removed) {
                    // Mark the MCP as unchecked if it was removed
                    state.setActionItemState('mcps', mcpName, false);
                }
                // Use includeFile which properly handles saving and rendering
                window.workspaceManager.includeFile(result.path, result.content);
            }
        }
    } catch (error) {
        console.error(`Error installing MCP: ${error.message}`);
    }
}

async function installRule(ruleName) {
    try {
        const response = await fetch(`/api/actions/rule-content/${encodeURIComponent(ruleName)}`);
        
        if (response.ok) {
            const result = await response.json();
            
            let currentContent = '';
            if (window.workspaceManager && window.workspaceManager.getState()) {
                const claudeFile = window.workspaceManager.getState().files['CLAUDE.md'];
                if (claudeFile) {
                    currentContent = claudeFile;
                }
            }
            
            const ruleContent = result.content.trim();
            const newContent = currentContent + (currentContent ? '\n' : '') + ruleContent;
            
            if (window.workspaceManager) {
                // Use includeFile which properly handles saving and rendering
                window.workspaceManager.includeFile('CLAUDE.md', newContent);
            }
        }
    } catch (error) {
        console.error(`Error installing rule: ${error.message}`);
    }
}

// Remove functions for specific items
async function removeMCP(mcpName) {
    try {
        if (window.workspaceManager && window.workspaceManager.getState()) {
            const state = window.workspaceManager.getState();
            const mcpFile = state.files['.mcp.json'];
            
            if (mcpFile) {
                try {
                    let config = JSON.parse(mcpFile);
                    // Remove the specific MCP from config - use correct property name
                    if (config.mcpServers && config.mcpServers[mcpName]) {
                        delete config.mcpServers[mcpName];
                    }
                    
                    // Check if there are any MCPs left
                    const hasRemainingMCPs = config.mcpServers && Object.keys(config.mcpServers).length > 0;
                    
                    if (hasRemainingMCPs) {
                        // Update the file with cleaned config
                        const newContent = JSON.stringify(config, null, 2);
                        // Use includeFile which properly handles saving and rendering
                        window.workspaceManager.includeFile('.mcp.json', newContent);
                    } else {
                        // No MCPs left, remove the file entirely
                        window.workspaceManager.deleteFile('.mcp.json');
                    }
                } catch (e) {
                    console.error('Error parsing MCP config:', e);
                }
            }
        }
    } catch (error) {
        console.error(`Error removing MCP: ${error.message}`);
    }
}

async function removeRule(ruleName) {
    try {
        // Get the rule content first to know what to remove
        const response = await fetch(`/api/actions/rule-content/${encodeURIComponent(ruleName)}`);
        
        if (response.ok) {
            const result = await response.json();
            const ruleContent = result.content.trim();
            
            if (window.workspaceManager && window.workspaceManager.getState()) {
                const claudeFile = window.workspaceManager.getState().files['CLAUDE.md'];
                if (claudeFile && claudeFile.includes(ruleContent)) {
                    // Remove the rule content
                    const newContent = claudeFile
                        .replace(ruleContent, '')
                        .replace(/\n\n+/g, '\n\n')
                        .trim();
                    
                    // Mark the rule as unchecked in action state
                    const state = window.workspaceManager.getState();
                    if (state) {
                        state.setActionItemState('rules', ruleName, false);
                    }
                    
                    // Check if file is empty or only whitespace
                    if (newContent === '' || newContent.match(/^\s*$/)) {
                        // File is empty, remove it entirely
                        window.workspaceManager.deleteFile('CLAUDE.md');
                    } else {
                        // Use includeFile which properly handles saving and rendering
                        window.workspaceManager.includeFile('CLAUDE.md', newContent);
                    }
                }
            }
        }
    } catch (error) {
        console.error(`Error removing rule: ${error.message}`);
    }
}

async function removeAgent(agentName) {
    try {
        if (window.workspaceManager) {
            const state = window.workspaceManager.getState();
            if (!state) return;
            
            let filesToRemove = [];
            
            // First check if we have a stored mapping for this agent
            if (state.agentMappings && state.agentMappings[agentName]) {
                const mappedPath = state.agentMappings[agentName];
                if (state.files[mappedPath]) {
                    filesToRemove.push(mappedPath);
                }
                // Clean up the mapping
                delete state.agentMappings[agentName];
            }
            
            // If no mapping found, search for the agent file
            if (filesToRemove.length === 0) {
                // Find files in .claude/agents/ directory that match this agent
                filesToRemove = Object.keys(state.files).filter(path => {
                    // Check for both .yaml and .md extensions
                    const normalizedAgentName = agentName.toLowerCase().replace(/[-\s]/g, '[-_]?');
                    const regex = new RegExp(`\.claude/agents/.*${normalizedAgentName}.*\.(yaml|md)$`, 'i');
                    return regex.test(path);
                });
                
                // If still no match, try alternative path patterns
                if (filesToRemove.length === 0) {
                    const alternativePaths = [
                        `.claude/agents/${agentName}.yaml`,
                        `.claude/agents/${agentName}.md`,
                        `.claude/agents/${agentName.replace(/[-\s]/g, '_')}.md`,
                        `.claude/agents/${agentName.replace(/[-\s]/g, '-')}.md`
                    ];
                    
                    alternativePaths.forEach(path => {
                        if (state.files[path]) {
                            filesToRemove.push(path);
                        }
                    });
                }
            }
            
            // Mark the agent as unchecked in action state
            state.setActionItemState('agents', agentName, false);
            
            // Remove all found files - use workspaceManager.deleteFile for proper updates
            if (filesToRemove.length > 0) {
                filesToRemove.forEach(path => {
                    // Use workspaceManager.deleteFile which triggers render
                    window.workspaceManager.deleteFile(path);
                });
                // Save state after agent mappings update
                window.workspaceManager.saveState(window.workspaceManager.currentContextId);
            } else {
                console.warn(`No agent files found for: ${agentName}. Mapped path: ${state.agentMappings?.[agentName] || 'none'}`);
                // Still save state for the action state update
                window.workspaceManager.saveState(window.workspaceManager.currentContextId);
            }
        }
    } catch (error) {
        console.error(`Error removing agent: ${error.message}`);
    }
}
</script>