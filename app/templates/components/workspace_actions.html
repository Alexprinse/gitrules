<!-- Right Panel: Add tools -->
<div class="workspace-actions">
    <div class="p-4">
        <h3 class="text-lg font-black text-black mb-4">Add tools</h3>
        
        <!-- QuickAction Section - Search Bar -->
        <div class="mb-4">
            <h4 class="text-sm font-bold text-black mb-2">Quick Action</h4>
            <div class="search-container">
                <input 
                    type="text" 
                    class="search-input"
                    placeholder="Search actions..."
                    onkeyup="searchActions(this.value)"
                />
                <div class="search-results" id="search-results" style="display: none;"></div>
            </div>
        </div>

        <!-- Toggle Menu Buttons -->
        <div class="mb-4">
            <h4 class="text-sm font-bold text-black mb-2">Actions</h4>
            
            <!-- MCPs Button with Expand -->
            <div class="menu-item mb-2">
                <button 
                    class="menu-button expandable"
                    data-theme="yellow"
                    onclick="toggleMenuButton(this, 'mcps')"
                >
                    <span class="menu-button-plus">+</span>
                    <span class="menu-button-text">MCPs</span>
                    <span class="menu-button-expand">▼</span>
                </button>
                <div class="menu-dropdown" id="dropdown-mcps" style="display: none;">
                    <div id="mcps-list" class="p-2">
                        <div class="text-xs text-gray-500">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Rules Button with Expand -->
            <div class="menu-item mb-2">
                <button 
                    class="menu-button expandable"
                    data-theme="pink"
                    onclick="toggleMenuButton(this, 'rules')"
                >
                    <span class="menu-button-plus">+</span>
                    <span class="menu-button-text">Rules</span>
                    <span class="menu-button-expand">▼</span>
                </button>
                <div class="menu-dropdown" id="dropdown-rules" style="display: none;">
                    <div id="rules-list" class="p-2">
                        <div class="text-xs text-gray-500">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Agents Button with Expand -->
            <div class="menu-item mb-2">
                <button 
                    class="menu-button expandable"
                    data-theme="blue"
                    onclick="toggleMenuButton(this, 'agents')"
                >
                    <span class="menu-button-plus">+</span>
                    <span class="menu-button-text">Agents</span>
                    <span class="menu-button-expand">▼</span>
                </button>
                <div class="menu-dropdown" id="dropdown-agents" style="display: none;">
                    <div id="agents-list" class="p-2">
                        <div class="text-xs text-gray-500">Loading...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* Workspace actions sidebar */
.workspace-actions {
    background: white;
    border-left: 2px solid black;
    min-height: 100%;
    height: 100%;
}

/* Search Container */
.search-container {
    position: relative;
}

.search-input {
    width: 100%;
    padding: 8px 12px;
    border: 2px solid black;
    font-size: 14px;
    background: white;
    box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    transition: all 150ms ease;
}

.search-input:focus {
    outline: none;
    box-shadow: 3px 3px 0px 0px rgba(0,0,0,1);
    transform: translate(-1px, -1px);
}

.search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    margin-top: 4px;
    background: white;
    border: 2px solid black;
    box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    max-height: 200px;
    overflow-y: auto;
    z-index: 10;
}

.search-result-item {
    padding: 6px 10px;
    font-size: 13px;
    cursor: pointer;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    align-items: center;
    gap: 6px;
}

.search-result-item:last-child {
    border-bottom: none;
}

.search-result-item:hover {
    background: #f3f4f6;
}

.search-result-type {
    font-size: 10px;
    font-weight: bold;
    padding: 2px 4px;
    border: 1px solid black;
    background: #f3f4f6;
}

/* Menu Button Base Style */
.menu-button {
    width: 100%;
    display: flex;
    align-items: center;
    background: white;
    border: 2px solid black;
    padding: 0;
    font-weight: bold;
    font-size: 14px;
    cursor: pointer;
    transition: all 150ms ease;
    box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    position: relative;
    overflow: hidden;
}

/* Plus icon area */
.menu-button-plus {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    font-weight: bold;
    border-right: 2px solid black;
    flex-shrink: 0;
}

/* Text area */
.menu-button-text {
    flex: 1;
    padding: 0 12px;
    color: black;
    text-align: left;
}

/* Expand arrow */
.menu-button-expand {
    padding: 0 12px;
    font-size: 12px;
    color: black;
    transition: transform 150ms ease;
}

/* Theme colors for plus area (default state) */
.menu-button[data-theme="yellow"] .menu-button-plus {
    background: #FDE047;
}

.menu-button[data-theme="pink"] .menu-button-plus {
    background: #F472B6;
}

.menu-button[data-theme="blue"] .menu-button-plus {
    background: #22D3EE;
}

/* Toggled state - color inversion (color moves to text area) */
.menu-button.toggled[data-theme="yellow"] {
    background: #FDE047;
}

.menu-button.toggled[data-theme="yellow"] .menu-button-plus {
    background: white;
}

.menu-button.toggled[data-theme="pink"] {
    background: #F472B6;
}

.menu-button.toggled[data-theme="pink"] .menu-button-plus {
    background: white;
}

.menu-button.toggled[data-theme="blue"] {
    background: #22D3EE;
}

.menu-button.toggled[data-theme="blue"] .menu-button-plus {
    background: white;
}

/* Text always stays black */
.menu-button .menu-button-text,
.menu-button.toggled .menu-button-text {
    color: black;
}

/* Expanded state */
.menu-button.expanded .menu-button-expand {
    transform: rotate(180deg);
}

/* Hover effect */
.menu-button:hover {
    box-shadow: 3px 3px 0px 0px rgba(0,0,0,1);
    transform: translate(-1px, -1px);
}

/* Active/pressed effect */
.menu-button:active {
    box-shadow: 1px 1px 0px 0px rgba(0,0,0,1);
    transform: translate(1px, 1px);
}

/* Dropdown container */
.menu-dropdown {
    background: white;
    border: 2px solid black;
    border-top: none;
    margin-top: -2px;
    box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
}

/* List items in dropdown */
.dropdown-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 8px;
    font-size: 12px;
    cursor: pointer;
    transition: background 100ms ease;
}

.dropdown-item:hover {
    background: #f3f4f6;
}

.dropdown-item.active {
    background: #e5e7eb;
    font-weight: bold;
}

.dropdown-item-icon {
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    border: 1px solid black;
}

.dropdown-item.active .dropdown-item-icon {
    background: black;
    color: white;
}
</style>

<script>
// Track toggled buttons and expanded states
let toggledButtons = {};
let expandedButtons = {};
let loadedData = {};

// Search functionality
let allActions = [];
let searchTimeout = null;

// Initialize search data
async function initSearchData() {
    try {
        const response = await fetch('/api/actions/');
        if (response.ok) {
            const data = await response.json();
            allActions = [
                ...(data.mcps || []).map(item => ({...item, type: 'MCP'})),
                ...(data.rules || []).map(item => ({...item, type: 'Rule'})),
                ...(data.agents || []).map(item => ({...item, type: 'Agent'}))
            ];
        }
    } catch (error) {
        console.error('Error loading search data:', error);
    }
}

// Search actions
function searchActions(query) {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        const resultsContainer = document.getElementById('search-results');
        
        if (!query || query.trim() === '') {
            resultsContainer.style.display = 'none';
            return;
        }
        
        const searchTerm = query.toLowerCase();
        const filtered = allActions.filter(action => 
            action.name.toLowerCase().includes(searchTerm)
        );
        
        if (filtered.length > 0) {
            resultsContainer.innerHTML = filtered.map(action => `
                <div class="search-result-item" onclick="selectSearchResult('${action.name}', '${action.type}')">
                    <span class="search-result-type">${action.type}</span>
                    <span>${action.name}</span>
                </div>
            `).join('');
            resultsContainer.style.display = 'block';
        } else {
            resultsContainer.innerHTML = '<div class="search-result-item">No results found</div>';
            resultsContainer.style.display = 'block';
        }
    }, 200);
}

// Select search result
async function selectSearchResult(name, type) {
    const resultsContainer = document.getElementById('search-results');
    const searchInput = document.querySelector('.search-input');
    
    // Clear search
    searchInput.value = '';
    resultsContainer.style.display = 'none';
    
    // Install the selected action
    if (type === 'MCP') {
        await installMCP(name);
    } else if (type === 'Rule') {
        await installRule(name);
    } else if (type === 'Agent') {
        await installAgent(name);
    }
}

// Initialize search on load
document.addEventListener('DOMContentLoaded', function() {
    initSearchData();
});

// Toggle menu button - handles both toggle and expand together
function toggleMenuButton(button, type) {
    const isToggled = button.classList.contains('toggled');
    const dropdown = document.getElementById(`dropdown-${type}`);
    
    // Toggle the button state
    if (isToggled) {
        button.classList.remove('toggled');
        button.classList.remove('expanded');
        toggledButtons[type] = false;
        expandedButtons[type] = false;
        dropdown.style.display = 'none';
        // Remove from context
        removeFromContext(type);
    } else {
        button.classList.add('toggled');
        button.classList.add('expanded');
        toggledButtons[type] = true;
        expandedButtons[type] = true;
        dropdown.style.display = 'block';
        // Insert into context
        insertIntoContext(type);
        // Load data if needed
        if (!loadedData[type]) {
            loadDropdownData(type);
            loadedData[type] = true;
        }
    }
}

// Insert action into context
async function insertIntoContext(type) {
    if (type === 'agents') {
        // Default agent insertion
        const defaultAgent = 'code-searcher';
        await installAgent(defaultAgent);
    } else if (type === 'mcps') {
        // Default MCP insertion
        const defaultMcp = 'filesystem';
        await installMCP(defaultMcp);
    } else if (type === 'rules') {
        // Default rule insertion
        const defaultRule = 'code-quality';
        await installRule(defaultRule);
    }
}

// Remove action from context
async function removeFromContext(type) {
    if (window.workspaceManager && window.workspaceManager.currentState) {
        const state = window.workspaceManager.currentState;
        
        if (type === 'agents') {
            // Remove agent files
            const agentFiles = Object.keys(state.files).filter(f => f.startsWith('.gitrules/agents/'));
            agentFiles.forEach(file => {
                delete state.files[file];
            });
        } else if (type === 'mcps') {
            // Remove MCP config
            delete state.files['.mcp.json'];
        } else if (type === 'rules') {
            // Clear rules from CLAUDE.md
            if (state.files['CLAUDE.md']) {
                state.files['CLAUDE.md'] = '';
            }
        }
        
        window.workspaceManager.saveState(window.workspaceManager.currentContextId);
        window.workspaceManager.render();
    }
}

// Load dropdown data
async function loadDropdownData(type) {
    try {
        const response = await fetch('/api/actions/');
        if (!response.ok) throw new Error('Failed to fetch actions');
        
        const data = await response.json();
        let container, items;
        
        switch(type) {
            case 'mcps':
                container = document.getElementById('mcps-list');
                items = data.mcps || [];
                break;
            case 'rules':
                container = document.getElementById('rules-list');
                items = data.rules || [];
                break;
            case 'agents':
                container = document.getElementById('agents-list');
                items = data.agents || [];
                break;
        }
        
        if (container && items.length > 0) {
            container.innerHTML = items.map(item => `
                <div 
                    class="dropdown-item"
                    onclick="toggleDropdownItem(this, '${item.name}', '${type}')"
                >
                    <span class="dropdown-item-icon">+</span>
                    <span>${item.name}</span>
                </div>
            `).join('');
        }
    } catch (error) {
        console.error(`Error loading ${type}:`, error);
    }
}

// Toggle individual dropdown item
function toggleDropdownItem(element, itemName, type) {
    element.classList.toggle('active');
    const icon = element.querySelector('.dropdown-item-icon');
    
    if (element.classList.contains('active')) {
        icon.textContent = '−';
        // Install the specific item
        if (type === 'mcps') {
            installMCP(itemName);
        } else if (type === 'rules') {
            installRule(itemName);
        } else if (type === 'agents') {
            installAgent(itemName);
        }
    } else {
        icon.textContent = '+';
        // Remove the specific item
        if (type === 'mcps') {
            removeMCP(itemName);
        } else if (type === 'rules') {
            removeRule(itemName);
        } else if (type === 'agents') {
            removeAgent(itemName);
        }
    }
}

// Backend integration functions (from previous implementation)
async function installAgent(agentName) {
    try {
        const response = await fetch(`/api/actions/agent-content/${encodeURIComponent(agentName)}`);
        
        if (response.ok) {
            const result = await response.json();
            
            if (window.workspaceManager && window.workspaceManager.currentState) {
                // Store the agent file
                window.workspaceManager.currentState.addFile(result.path, result.content);
                
                // Store agent name to path mapping in metadata (for easier removal)
                if (!window.workspaceManager.currentState.agentMappings) {
                    window.workspaceManager.currentState.agentMappings = {};
                }
                window.workspaceManager.currentState.agentMappings[agentName] = result.path;
                
                window.workspaceManager.saveState(window.workspaceManager.currentContextId);
                window.workspaceManager.render();
            }
        }
    } catch (error) {
        console.error(`Error installing agent: ${error.message}`);
    }
}

async function installMCP(mcpName) {
    try {
        let currentConfig = {};
        if (window.workspaceManager && window.workspaceManager.getState()) {
            const mcpFile = window.workspaceManager.getState().files['.mcp.json'];
            if (mcpFile) {
                try {
                    currentConfig = JSON.parse(mcpFile);
                } catch (e) {
                    currentConfig = {};
                }
            }
        }
        
        const response = await fetch(`/api/actions/mcp-config/${encodeURIComponent(mcpName)}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(currentConfig)
        });
        
        if (response.ok) {
            const result = await response.json();
            
            if (window.workspaceManager && window.workspaceManager.currentState) {
                window.workspaceManager.currentState.addFile(result.path, result.content);
                window.workspaceManager.saveState(window.workspaceManager.currentContextId);
                window.workspaceManager.render();
            }
        }
    } catch (error) {
        console.error(`Error installing MCP: ${error.message}`);
    }
}

async function installRule(ruleName) {
    try {
        const response = await fetch(`/api/actions/rule-content/${encodeURIComponent(ruleName)}`);
        
        if (response.ok) {
            const result = await response.json();
            
            let currentContent = '';
            if (window.workspaceManager && window.workspaceManager.getState()) {
                const claudeFile = window.workspaceManager.getState().files['CLAUDE.md'];
                if (claudeFile) {
                    currentContent = claudeFile;
                }
            }
            
            const ruleContent = result.content.trim();
            const newContent = currentContent + (currentContent ? '\n' : '') + ruleContent;
            
            if (window.workspaceManager && window.workspaceManager.currentState) {
                window.workspaceManager.currentState.addFile('CLAUDE.md', newContent);
                window.workspaceManager.saveState(window.workspaceManager.currentContextId);
                window.workspaceManager.render();
            }
        }
    } catch (error) {
        console.error(`Error installing rule: ${error.message}`);
    }
}

// Remove functions for specific items
async function removeMCP(mcpName) {
    try {
        if (window.workspaceManager && window.workspaceManager.getState()) {
            const state = window.workspaceManager.getState();
            const mcpFile = state.files['.mcp.json'];
            
            if (mcpFile) {
                try {
                    let config = JSON.parse(mcpFile);
                    // Remove the specific MCP from config - use correct property name
                    if (config.mcpServers && config.mcpServers[mcpName]) {
                        delete config.mcpServers[mcpName];
                    }
                    
                    // If no MCPs left, keep the file with empty mcpServers object
                    if (!config.mcpServers) {
                        config.mcpServers = {};
                    }
                    
                    // Update the file with cleaned config
                    const newContent = JSON.stringify(config, null, 2);
                    window.workspaceManager.currentState.addFile('.mcp.json', newContent);
                    window.workspaceManager.saveState(window.workspaceManager.currentContextId);
                    window.workspaceManager.render();
                } catch (e) {
                    console.error('Error parsing MCP config:', e);
                }
            }
        }
    } catch (error) {
        console.error(`Error removing MCP: ${error.message}`);
    }
}

async function removeRule(ruleName) {
    try {
        // Get the rule content first to know what to remove
        const response = await fetch(`/api/actions/rule-content/${encodeURIComponent(ruleName)}`);
        
        if (response.ok) {
            const result = await response.json();
            const ruleContent = result.content.trim();
            
            if (window.workspaceManager && window.workspaceManager.getState()) {
                const claudeFile = window.workspaceManager.getState().files['CLAUDE.md'];
                if (claudeFile && claudeFile.includes(ruleContent)) {
                    // Remove the rule content
                    const newContent = claudeFile
                        .replace(ruleContent, '')
                        .replace(/\n\n+/g, '\n\n')
                        .trim();
                    
                    window.workspaceManager.currentState.addFile('CLAUDE.md', newContent);
                    window.workspaceManager.saveState(window.workspaceManager.currentContextId);
                    window.workspaceManager.render();
                }
            }
        }
    } catch (error) {
        console.error(`Error removing rule: ${error.message}`);
    }
}

async function removeAgent(agentName) {
    try {
        if (window.workspaceManager && window.workspaceManager.currentState) {
            const state = window.workspaceManager.currentState;
            let filesToRemove = [];
            
            // First check if we have a stored mapping for this agent
            if (state.agentMappings && state.agentMappings[agentName]) {
                const mappedPath = state.agentMappings[agentName];
                if (state.files[mappedPath]) {
                    filesToRemove.push(mappedPath);
                }
                // Clean up the mapping
                delete state.agentMappings[agentName];
            }
            
            // If no mapping found, search for the agent file
            if (filesToRemove.length === 0) {
                // Find files in .claude/agents/ directory that match this agent
                filesToRemove = Object.keys(state.files).filter(path => {
                    return path.startsWith('.claude/agents/') && 
                           path.toLowerCase().includes(agentName.toLowerCase().replace(/[-\s]/g, '_'));
                });
                
                // If still no match, try alternative path patterns
                if (filesToRemove.length === 0) {
                    const alternativePaths = [
                        `.claude/agents/${agentName}.md`,
                        `.claude/agents/${agentName.replace(/[-\s]/g, '_')}.md`,
                        `.claude/agents/${agentName.replace(/[-\s]/g, '-')}.md`
                    ];
                    
                    alternativePaths.forEach(path => {
                        if (state.files[path]) {
                            filesToRemove.push(path);
                        }
                    });
                }
            }
            
            // Remove all found files
            if (filesToRemove.length > 0) {
                filesToRemove.forEach(path => {
                    delete state.files[path];
                });
                window.workspaceManager.saveState(window.workspaceManager.currentContextId);
                window.workspaceManager.render();
            } else {
                console.warn(`No agent files found for: ${agentName}`);
            }
        }
    } catch (error) {
        console.error(`Error removing agent: ${error.message}`);
    }
}
</script>