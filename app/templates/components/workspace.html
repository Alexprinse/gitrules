<!-- Include ActionButton Component -->
{% include 'components/ActionButton.html' %}

<div class="mt-16" style="display: none;">
    <!-- Context switcher and tabs container -->
    <div class="flex justify-between items-end mb-0">
        <!-- Tabs floating above container -->
        <div class="flex gap-1 translate-x-1 translate-y-1">
            <button id="tab-claude" class="tab-button active px-4 py-2 bg-cyan-400 border-2 border-black border-b-0 text-black font-bold shadow-[2px_0px_0px_0px_rgba(0,0,0,1)] hover:shadow-[4px_0px_0px_0px_rgba(0,0,0,1)] hover:translate-x-[-1px] hover:translate-y-[-1px] active:shadow-[1px_0px_0px_0px_rgba(0,0,0,1)] active:translate-x-[1px] active:translate-y-[1px] transition-all text-sm relative z-10">
                CLAUDE
            </button>
            <button id="tab-cursor" class="tab-button px-4 py-2 bg-gray-100 border-2 border-gray-400 border-b-0 text-gray-700 font-medium shadow-[1px_0px_0px_0px_rgba(0,0,0,0.3)] hover:shadow-[2px_0px_0px_0px_rgba(0,0,0,0.3)] hover:translate-x-[-1px] hover:translate-y-[-1px] active:shadow-[0px_0px_0px_0px_rgba(0,0,0,0.3)] active:translate-x-[1px] active:translate-y-[1px] transition-all text-sm relative z-5">
                Cursor/others..
            </button>
        </div>
        
        <!-- Context switcher -->
        <div class="flex gap-2 items-center mb-1 mr-2">
            <label class="text-sm font-bold text-black">Context:</label>
            <select id="context-switcher" class="px-3 py-1 bg-white border-2 border-black text-black font-medium shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[3px_3px_0px_0px_rgba(0,0,0,1)] focus:outline-none focus:ring-2 focus:ring-cyan-400 text-sm">
                <!-- Options will be populated dynamically -->
            </select>
            <button id="new-context-btn" class="px-2 py-1 bg-pink-400 border-2 border-black text-black font-bold shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[3px_3px_0px_0px_rgba(0,0,0,1)] hover:translate-x-[-1px] hover:translate-y-[-1px] active:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:translate-x-[1px] active:translate-y-[1px] transition-all text-sm" title="New Context">
                +
            </button>
            <button id="delete-context-btn" class="px-2 py-1 bg-red-400 border-2 border-black text-black font-bold shadow-[2px_2px_0px_0px_rgba(0,0,0,1)] hover:shadow-[3px_3px_0px_0px_rgba(0,0,0,1)] hover:translate-x-[-1px] hover:translate-y-[-1px] active:shadow-[1px_1px_0px_0px_rgba(0,0,0,1)] active:translate-x-[1px] active:translate-y-[1px] transition-all text-sm" title="Delete Context">
                ×
            </button>
        </div>
    </div>

    <!-- Editor Container -->
    <div class="bg-white border-2 border-black shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] relative z-0">

        <!-- Three-panel layout inside container -->
        <div class="grid grid-cols-1 lg:grid-cols-3 h-96">
            {% include 'components/workspace_files.html' %}
            {% include 'components/workspace_editor.html' %}
            {% include 'components/workspace_actions.html' %}
        </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const workspaceTabs = document.querySelectorAll('.tab-button');
    
    workspaceTabs.forEach(tab => {
        tab.addEventListener('click', function() {
            // Remove active state from all tabs
            workspaceTabs.forEach(t => {
                t.classList.remove('active', 'bg-cyan-400', 'border-black', 'text-black', 'font-bold', 'z-10');
                t.classList.add('bg-gray-100', 'border-gray-400', 'text-gray-700', 'font-medium', 'z-5');
                t.classList.remove('shadow-[2px_0px_0px_0px_rgba(0,0,0,1)]');
                t.classList.add('shadow-[1px_0px_0px_0px_rgba(0,0,0,0.3)]');
            });
            
            // Add active state to clicked tab
            this.classList.add('active', 'bg-cyan-400', 'border-black', 'text-black', 'font-bold', 'z-10');
            this.classList.remove('bg-gray-100', 'border-gray-400', 'text-gray-700', 'font-medium', 'z-5');
            this.classList.remove('shadow-[1px_0px_0px_0px_rgba(0,0,0,0.3)]');
            this.classList.add('shadow-[2px_0px_0px_0px_rgba(0,0,0,1)]');
            
                    // Update panel contents based on selected tab
            updateWorkspaceContents(this.id);
        });
    });
});

function updateWorkspaceContents(tabId) {
    // Update file system and editor content based on tab
    updateWorkspaceFileSystem(tabId);
    updateWorkspaceEditor(tabId);
}

function updateWorkspaceFileSystem(tabId) {
    // File system now uses the persistent file tree
    // This function can be used to filter visible files based on tab context
    renderFileTree();
}

let workspaceMonacoEditor;

function initializeWorkspaceEditor() {
    require.config({ paths: { vs: 'https://unpkg.com/monaco-editor@0.44.0/min/vs' } });
    
    require(['vs/editor/editor.main'], function () {
        workspaceMonacoEditor = monaco.editor.create(document.getElementById('workspace-monaco-editor'), {
            value: `# My Agent Configuration

Click any QuickAction button to add it here...`,
            language: 'markdown',
            theme: 'vs',
            fontSize: 12,
            lineNumbers: 'on',
            minimap: { enabled: false },
            scrollBeyondLastLine: false,
            automaticLayout: true,
            wordWrap: 'on'
        });
        
        // Copy functionality
        document.getElementById('copy-workspace-editor').addEventListener('click', function() {
            const content = workspaceMonacoEditor.getValue();
            navigator.clipboard.writeText(content);
        });
        
        // Share functionality
        document.getElementById('share-install').addEventListener('click', async function() {
            // Collect all files from the file system
            const allFiles = {};
            
            // Helper function to collect files from tree structure
            function collectFilesFromTree(nodes, collected) {
                nodes.forEach(node => {
                    if (node.type === 'file' && !deletedFiles.has(node.path)) {
                        if (fileContent[node.path]) {
                            collected[node.path] = fileContent[node.path];
                        }
                    } else if (node.type === 'folder' && node.children) {
                        collectFilesFromTree(node.children, collected);
                    }
                });
            }
            
            // Collect files from dynamic tree
            const fileTreeData = generateFileTreeData();
            collectFilesFromTree(fileTreeData, allFiles);
            
            // Add user-created files
            userFiles.forEach(filePath => {
                if (!deletedFiles.has(filePath) && fileContent[filePath]) {
                    allFiles[filePath] = fileContent[filePath];
                }
            });
            
            try {
                // Send files to API to generate install script
                const response = await fetch('/api/install', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ files: allFiles })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to create install');
                }
                
                const data = await response.json();
                const installCommand = `sh -c "$(curl -fsSL ${window.location.origin}/api/install/${data.hash}.sh)"`;
                
                // Copy to clipboard
                await navigator.clipboard.writeText(installCommand);
                
                // Show feedback
                const button = document.getElementById('share-install');
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.remove('bg-pink-400');
                button.classList.add('bg-green-400');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('bg-green-400');
                    button.classList.add('bg-pink-400');
                }, 2000);
            } catch (error) {
                console.error('Error sharing install:', error);
                alert('Failed to share install. Please try again.');
            }
        });
        
        // Initialize QuickAction button handlers after editor is ready
        setTimeout(initializeQuickActionHandlers, 100);
    });
}

function insertTextAtCursor(text) {
    if (!workspaceMonacoEditor) return;
    
    const selection = workspaceMonacoEditor.getSelection();
    const position = selection.getStartPosition();
    
    workspaceMonacoEditor.executeEdits('quickaction-insert', [{
        range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
        text: text
    }]);
    
    // Move cursor to end of inserted text
    const newPosition = new monaco.Position(position.lineNumber, position.column + text.length);
    workspaceMonacoEditor.setPosition(newPosition);
    workspaceMonacoEditor.focus();
}

function initializeQuickActionHandlers() {
    // Helper function to extract button label
    function getButtonLabel(button) {
        const labelSpan = button.querySelector('span.font-bold');
        return labelSpan ? labelSpan.textContent.trim() : 'Unknown';
    }
    
    // Add handlers for main QuickAction buttons (above workspace)
    const mainQuickActionButtons = document.querySelectorAll('#quick-actions-section button');
    mainQuickActionButtons.forEach(button => {
        // Skip "See all..." buttons
        if (button.textContent.includes('See all')) return;
        
        button.addEventListener('click', function() {
            const label = getButtonLabel(this);
            insertTextAtCursor(label);
        });
    });
    
    // Add handlers for workspace panel QuickAction buttons
    const workspaceActionButtons = document.querySelectorAll('.qa-tab-content button');
    workspaceActionButtons.forEach(button => {
        button.addEventListener('click', function() {
            const label = getButtonLabel(this);
            insertTextAtCursor(label);
        });
    });
}

function updateWorkspaceEditor(tabId) {
    if (!workspaceMonacoEditor) return;
    
    const editorContent = {
        'tab-claude': {
            content: `# Claude Configuration

## Subagents
- Researcher: Information gathering specialist
- Memory Manager: Context and history management

## Guidelines
- Python: PEP 8 compliance, type hints
- Code quality: Clean, documented, tested

## MCPs (Model Context Protocols)
- Database integration
- File system access
- API connections`,
            language: 'markdown'
        },
        'tab-cursor': {
            content: `// Cursor/VS Code Configuration

{
  "rules": [
    "Always use TypeScript for new files",
    "Prefer functional components in React",
    "Use meaningful variable names",
    "Add JSDoc comments for functions"
  ],
  "preferences": {
    "tabSize": 2,
    "insertSpaces": true,
    "trimTrailingWhitespace": true
  },
  "extensions": [
    "Prettier",
    "ESLint",
    "GitLens",
    "Auto Rename Tag"
  ]
}`,
            language: 'json'
        }
    };
    
    const config = editorContent[tabId];
    if (config) {
        workspaceMonacoEditor.setValue(config.content);
        monaco.editor.setModelLanguage(workspaceMonacoEditor.getModel(), config.language);
        document.getElementById('workspace-language-select').value = config.language;
    }
}

// ============================================================================
// NEW UNIFIED STATE MANAGEMENT SYSTEM
// ============================================================================

/**
 * WorkspaceState - Manages all state for a single workspace context
 */
class WorkspaceState {
    constructor(contextId) {
        this.contextId = contextId;
        this.files = {};  // File path -> content mapping
        this.selectedFile = null;
        this.expandedFolders = new Set();
        this.history = {
            past: [],
            present: null,
            future: [],
            maxSize: 50
        };
    }

    // Initialize empty state
    initEmpty() {
        this.files = {};
        this.selectedFile = null;
        this.expandedFolders = new Set();
        this.history.present = this.snapshot();
        this.history.past = [];
        this.history.future = [];
    }

    // Create a snapshot of current state
    snapshot() {
        return {
            files: { ...this.files },
            selectedFile: this.selectedFile,
            expandedFolders: Array.from(this.expandedFolders),
            timestamp: new Date().toISOString()
        };
    }

    // Add a file (Include action)
    addFile(path, content) {
        // Save current state to history
        this.pushHistory();
        
        // Add the file
        this.files[path] = content;
        this.selectedFile = path;
        
        // Update history present
        this.history.present = this.snapshot();
    }

    // Delete a file
    deleteFile(path) {
        this.pushHistory();
        delete this.files[path];
        if (this.selectedFile === path) {
            this.selectedFile = null;
        }
        this.history.present = this.snapshot();
    }

    // Push current state to history
    pushHistory() {
        if (this.history.present) {
            this.history.past.push(this.history.present);
            if (this.history.past.length > this.history.maxSize) {
                this.history.past.shift();
            }
            this.history.future = [];
        }
    }

    // Go to previous state
    undo() {
        if (this.history.past.length === 0) return false;
        
        const previousState = this.history.past.pop();
        this.history.future.unshift(this.history.present);
        this.history.present = previousState;
        this.restoreFromSnapshot(previousState);
        return true;
    }

    // Go to next state
    redo() {
        if (this.history.future.length === 0) return false;
        
        const nextState = this.history.future.shift();
        this.history.past.push(this.history.present);
        this.history.present = nextState;
        this.restoreFromSnapshot(nextState);
        return true;
    }

    // Restore state from snapshot
    restoreFromSnapshot(snapshot) {
        this.files = { ...snapshot.files };
        this.selectedFile = snapshot.selectedFile;
        this.expandedFolders = new Set(snapshot.expandedFolders || []);
    }

    // Reset to empty state
    reset() {
        this.pushHistory();
        this.files = {};
        this.selectedFile = null;
        this.expandedFolders = new Set();
        this.history.present = this.snapshot();
    }

    // Check if we can undo/redo
    canUndo() {
        return this.history.past.length > 0;
    }

    canRedo() {
        return this.history.future.length > 0;
    }

    // Serialize state for localStorage
    serialize() {
        return JSON.stringify({
            contextId: this.contextId,
            files: this.files,
            selectedFile: this.selectedFile,
            expandedFolders: Array.from(this.expandedFolders),
            history: {
                past: this.history.past,
                present: this.history.present,
                future: this.history.future
            }
        });
    }

    // Deserialize state from localStorage
    static deserialize(contextId, data) {
        const state = new WorkspaceState(contextId);
        if (data) {
            try {
                const parsed = typeof data === 'string' ? JSON.parse(data) : data;
                state.files = parsed.files || {};
                state.selectedFile = parsed.selectedFile || null;
                state.expandedFolders = new Set(parsed.expandedFolders || []);
                
                if (parsed.history) {
                    state.history.past = parsed.history.past || [];
                    state.history.present = parsed.history.present || state.snapshot();
                    state.history.future = parsed.history.future || [];
                } else {
                    state.history.present = state.snapshot();
                }
            } catch (e) {
                console.error('Failed to deserialize state:', e);
                state.initEmpty();
            }
        } else {
            state.initEmpty();
        }
        return state;
    }
}

/**
 * WorkspaceManager - Manages multiple workspace contexts
 */
class WorkspaceManager {
    constructor() {
        this.contexts = {};
        this.currentContextId = null;
        this.currentState = null;
    }

    // Initialize the manager
    init() {
        // Load contexts list
        this.contexts = this.loadContextsList();
        
        // Ensure default context exists
        if (!this.contexts['default']) {
            this.createContext('default', 'Default Workspace');
        }
        
        // Get last active context or use default
        const lastContext = localStorage.getItem('app:currentContext');
        
        if (lastContext && this.contexts[lastContext]) {
            this.switchContext(lastContext);
        } else {
            this.switchContext('default');
        }
    }

    // Load contexts list from localStorage
    loadContextsList() {
        try {
            const data = localStorage.getItem('app:contexts');
            return data ? JSON.parse(data) : {};
        } catch {
            return {};
        }
    }

    // Save contexts list to localStorage
    saveContextsList() {
        localStorage.setItem('app:contexts', JSON.stringify(this.contexts));
    }

    // Create a new context
    createContext(id, name) {
        if (this.contexts[id]) {
            console.warn(`Context ${id} already exists`);
            return false;
        }
        
        this.contexts[id] = {
            id,
            name,
            createdAt: Date.now()
        };
        
        this.saveContextsList();
        return true;
    }

    // Switch to a different context
    switchContext(contextId) {
        if (!this.contexts[contextId] && contextId !== 'default') {
            // Try to load from saved contexts
            const saved = this.loadContextsList();
            if (!saved[contextId]) {
                console.error(`Context ${contextId} not found`);
                return false;
            }
            this.contexts = saved;
        }
        
        // Save current state if exists
        if (this.currentState) {
            this.saveState(this.currentContextId);
        }
        
        // Load new context state
        this.currentContextId = contextId;
        this.currentState = this.loadState(contextId);
        
        // Update localStorage current context
        localStorage.setItem('app:currentContext', contextId);
        
        // Trigger UI update
        this.render();
        
        return true;
    }

    // Delete a context
    deleteContext(contextId) {
        if (contextId === 'default') {
            console.warn('Cannot delete default context');
            return false;
        }
        
        delete this.contexts[contextId];
        localStorage.removeItem(`app:workspace:${contextId}`);
        this.saveContextsList();
        
        // Switch to default if deleting current
        if (this.currentContextId === contextId) {
            this.switchContext('default');
        }
        
        return true;
    }

    // Save state to localStorage
    saveState(contextId) {
        if (!this.currentState) return;
        
        const key = `app:workspace:${contextId}`;
        localStorage.setItem(key, this.currentState.serialize());
    }

    // Load state from localStorage
    loadState(contextId) {
        const key = `app:workspace:${contextId}`;
        const data = localStorage.getItem(key);
        return WorkspaceState.deserialize(contextId, data);
    }

    // Get current state
    getState() {
        return this.currentState;
    }

    // Render the UI based on current state
    render() {
        if (!this.currentState) return;
        
        // Update file tree
        renderFileTree();
        
        // Update editor
        if (this.currentState.selectedFile && this.currentState.files[this.currentState.selectedFile]) {
            openFile(this.currentState.selectedFile);
        } else {
            if (window.workspaceMonacoEditor) {
                window.workspaceMonacoEditor.setValue('Select a file from the left to view its content.');
            }
            updateFilePathLabel(null);
        }
        
        // Update history buttons
        this.updateHistoryButtons();
        
        // Update context dropdown
        this.updateContextDropdown();
    }

    // Update history button states
    updateHistoryButtons() {
        const prevBtn = document.getElementById('files-prev-btn');
        const nextBtn = document.getElementById('files-next-btn');
        
        if (prevBtn) {
            prevBtn.disabled = !this.currentState.canUndo();
        }
        if (nextBtn) {
            nextBtn.disabled = !this.currentState.canRedo();
        }
    }

    // Update context dropdown
    updateContextDropdown() {
        const contextSwitcher = document.getElementById('context-switcher');
        if (!contextSwitcher) return;
        
        contextSwitcher.innerHTML = '';
        Object.values(this.contexts).forEach(ctx => {
            const option = document.createElement('option');
            option.value = ctx.id;
            option.textContent = ctx.name;
            option.selected = ctx.id === this.currentContextId;
            contextSwitcher.appendChild(option);
        });
    }

    // Include a file (main action for adding files)
    includeFile(path, content) {
        if (!this.currentState) return false;
        
        // Check if file exists
        if (this.currentState.files[path]) {
            if (!confirm(`File "${path}" already exists. Overwrite?`)) {
                return false;
            }
        }
        
        this.currentState.addFile(path, content);
        this.saveState(this.currentContextId);
        this.render();
        return true;
    }

    // Delete a file
    deleteFile(path) {
        if (!this.currentState) return false;
        
        if (!confirm(`Delete "${path}"?`)) {
            return false;
        }
        
        this.currentState.deleteFile(path);
        this.saveState(this.currentContextId);
        this.render();
        return true;
    }

    // Undo action
    undo() {
        if (!this.currentState) return;
        
        if (this.currentState.undo()) {
            this.saveState(this.currentContextId);
            this.render();
        }
    }

    // Redo action
    redo() {
        if (!this.currentState) return;
        
        if (this.currentState.redo()) {
            this.saveState(this.currentContextId);
            this.render();
        }
    }

    // Reset current workspace
    reset() {
        if (!this.currentState) return;
        
        if (confirm('Reset will clear all files. Are you sure?')) {
            this.currentState.reset();
            this.saveState(this.currentContextId);
            this.render();
        }
    }
}

// Create global workspace manager instance
const workspaceManager = new WorkspaceManager();
window.workspaceManager = workspaceManager;

// ============================================================================
// COMPATIBILITY LAYER - Maps old functions to new system
// ============================================================================

// Keep this for compatibility but it now uses the WorkspaceManager
const fileContent = new Proxy({}, {
    get(target, prop) {
        const state = workspaceManager.getState();
        return state ? state.files[prop] : undefined;
    },
    set(target, prop, value) {
        const state = workspaceManager.getState();
        if (state) {
            state.files[prop] = value;
        }
        return true;
    },
    deleteProperty(target, prop) {
        const state = workspaceManager.getState();
        if (state) {
            delete state.files[prop];
        }
        return true;
    },
    has(target, prop) {
        const state = workspaceManager.getState();
        return state ? prop in state.files : false;
    },
    ownKeys(target) {
        const state = workspaceManager.getState();
        return state ? Object.keys(state.files) : [];
    }
});

// Generate file tree structure dynamically from fileContent  
function generateFileTreeData() {
    const tree = {};
    const state = workspaceManager.getState();
    if (!state) return [];
    
    const files = Object.keys(state.files);
    
    // Build nested tree structure
    files.forEach(filePath => {
        const parts = filePath.split('/');
        let current = tree;
        
        // Create folder nodes
        for (let i = 0; i < parts.length - 1; i++) {
            const folderName = parts[i];
            const folderPath = parts.slice(0, i + 1).join('/');
            
            if (!current[folderName]) {
                current[folderName] = {
                    type: 'folder',
                    path: folderPath,
                    name: folderName,
                    children: {}
                };
            }
            current = current[folderName].children;
        }
        
        // Add file node
        const fileName = parts[parts.length - 1];
        current[fileName] = {
            type: 'file',
            path: filePath,
            name: fileName
        };
    });
    
    // Convert to array format expected by renderer
    function convertToArray(obj) {
        return Object.values(obj).map(node => {
            if (node.type === 'folder') {
                return {
                    ...node,
                    children: convertToArray(node.children)
                };
            }
            return node;
        });
    }
    
    return convertToArray(tree);
}

// OLD CODE REMOVED - Now using WorkspaceManager
// The fileContent object is now a Proxy that uses the WorkspaceManager

// OLD Context management - TO BE REMOVED
let currentContext = null;

function initContextManager() {
    // Get or create default context
    const contexts = safeGetRawJSON('app:contexts', {});
    const lastContext = safeGetRaw('app:currentContext');
    
    if (lastContext && contexts[lastContext]) {
        currentContext = lastContext;
    } else {
        // Create default context if none exists
        currentContext = 'default';
        if (!contexts[currentContext]) {
            contexts[currentContext] = {
                id: 'default',
                name: 'Default Workspace',
                createdAt: Date.now()
            };
            safeSetRaw('app:contexts', JSON.stringify(contexts));
        }
        safeSetRaw('app:currentContext', currentContext);
    }
}

window.createContext = function(id, name) {
    const contexts = safeGetRawJSON('app:contexts', {});
    if (contexts[id]) {
        console.warn(`Context ${id} already exists`);
        return false;
    }
    
    contexts[id] = {
        id,
        name,
        createdAt: Date.now()
    };
    
    safeSetRaw('app:contexts', JSON.stringify(contexts));
    return true;
}

window.switchContext = function(contextId) {
    const contexts = safeGetRawJSON('app:contexts', {});
    if (!contexts[contextId]) {
        console.error(`Context ${contextId} not found`);
        return false;
    }
    
    currentContext = contextId;
    safeSetRaw('app:currentContext', contextId);
    
    // Reload workspace state for new context
    if (typeof initializeFileTree === 'function') {
        initializeFileTree();
    }
    
    // Update context UI if available
    const contextSwitcher = document.getElementById('context-switcher');
    if (contextSwitcher) {
        contextSwitcher.value = contextId;
    }
    
    return true;
}

function deleteContext(contextId) {
    if (contextId === 'default') {
        console.warn('Cannot delete default context');
        return false;
    }
    
    const contexts = safeGetRawJSON('app:contexts', {});
    if (!contexts[contextId]) {
        console.error(`Context ${contextId} not found`);
        return false;
    }
    
    // Delete all context data
    const keysToDelete = [
        `app:${contextId}:fileTreeState`,
        `app:${contextId}:selectedFilePath`,
        `app:${contextId}:userFiles`,
        `app:${contextId}:deletedFiles`,
        `app:${contextId}:userFileContents`
    ];
    
    keysToDelete.forEach(key => {
        try { localStorage.removeItem(key); } catch {}
    });
    
    delete contexts[contextId];
    safeSetRaw('app:contexts', JSON.stringify(contexts));
    
    // Switch to default context if deleting current
    if (currentContext === contextId) {
        switchContext('default');
    }
    
    return true;
}

function getContextKey(key) {
    if (!currentContext) {
        initContextManager();
    }
    return `app:${currentContext}:${key}`;
}

// Raw persistence helpers (for non-context data)
function safeGetRaw(key) {
    try { return localStorage.getItem(key); } catch { return null; }
}

function safeSetRaw(key, value) {
    try { localStorage.setItem(key, value); } catch {}
}

function safeGetRawJSON(key, fallback) {
    try { 
        const value = localStorage.getItem(key); 
        return value ? JSON.parse(value) : fallback; 
    } catch { 
        return fallback; 
    }
}

// Context-aware persistence helpers
function safeGet(key) {
    return safeGetRaw(getContextKey(key));
}

function safeSet(key, value) {
    safeSetRaw(getContextKey(key), value);
}

function safeGetJSON(key, fallback) {
    return safeGetRawJSON(getContextKey(key), fallback);
}

// OLD GLOBAL VARIABLES - REPLACED BY WorkspaceManager
// These are now managed inside WorkspaceState class
// let selectedFilePath = null;
// let expandedFolders = new Set();
// let userFiles = new Set(); 
// let deletedFiles = new Set();
// let filesHistory = { past: [], present: null, future: [] };

// Create proxy objects for backward compatibility
const selectedFilePath = new Proxy({}, {
    get() { const s = workspaceManager.getState(); return s ? s.selectedFile : null; },
    set(t, p, v) { const s = workspaceManager.getState(); if (s) s.selectedFile = v; return true; }
});

const expandedFolders = new Proxy(new Set(), {
    get(target, prop) {
        const state = workspaceManager.getState();
        if (!state) return target[prop];
        if (prop === 'has') return (v) => state.expandedFolders.has(v);
        if (prop === 'add') return (v) => state.expandedFolders.add(v);
        if (prop === 'delete') return (v) => state.expandedFolders.delete(v);
        if (prop === 'clear') return () => state.expandedFolders.clear();
        return target[prop];
    }
});

// These are no longer needed - files are tracked in state.files
const userFiles = new Set();
const deletedFiles = new Set();

// OLD FUNCTIONS - Now simple wrappers around WorkspaceManager
function goToPrevious() {
    workspaceManager.undo();
}

function goToNext() {
    workspaceManager.redo();
}

function resetFiles() {
    workspaceManager.reset();
}

function updateHistoryButtons() {
    workspaceManager.updateHistoryButtons();
}

// Load file content
async function loadFile(path) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (fileContent[path]) {
                resolve(fileContent[path]);
            } else {
                reject(new Error(`File not found: ${path}`));
            }
        }, 50); // Simulate loading delay
    });
}

// Render file tree
function renderFileTree() {
    const treeContainer = document.getElementById('file-tree');
    const emptyStateEl = document.getElementById('files-empty-state');
    if (!treeContainer) return;
    
    treeContainer.innerHTML = '';
    
    const state = workspaceManager.getState();
    const hasFiles = state && Object.keys(state.files).length > 0;
    
    if (!hasFiles) {
        // Show empty state
        if (emptyStateEl) {
            emptyStateEl.classList.remove('hidden');
        }
        return;
    } else {
        // Hide empty state
        if (emptyStateEl) {
            emptyStateEl.classList.add('hidden');
        }
    }
    
    function renderNode(node, level = 0) {
        const div = document.createElement('div');
        div.style.paddingLeft = `${level * 16}px`;
        
        if (node.type === 'folder') {
            const state = workspaceManager.getState();
            const isExpanded = state && state.expandedFolders.has(node.path);
            div.innerHTML = `
                <div class="flex items-center gap-1 p-1 hover:bg-gray-100 cursor-pointer folder-toggle" data-path="${node.path}">
                    <svg class="w-3 h-3 transition-transform ${isExpanded ? 'rotate-90' : ''}" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M7 7l3 3 3-3" stroke="currentColor" stroke-width="2" fill="none"/>
                    </svg>
                    <svg class="w-4 h-4 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z"/>
                    </svg>
                    <span class="font-medium">${node.name}</span>
                </div>
            `;
            
            treeContainer.appendChild(div);
            
            if (isExpanded && node.children) {
                node.children.forEach(child => renderNode(child, level + 1));
            }
        } else {
            // File node
            const state = workspaceManager.getState();
            const isSelected = state && state.selectedFile === node.path;
            const isUserFile = true; // All files are user files now
            div.innerHTML = `
                <div class="flex items-center justify-between p-1 hover:bg-gray-100 cursor-pointer file-item ${isSelected ? 'bg-cyan-100 font-medium' : ''}" data-path="${node.path}">
                    <div class="flex items-center gap-1">
                        <span class="w-3"></span>
                        <svg class="w-4 h-4 text-gray-600" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M4 4a2 2 0 00-2 2v8a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2H4z"/>
                        </svg>
                        <span>${node.name}</span>
                        ${isUserFile ? '<span class="text-xs text-blue-600 ml-1">✓</span>' : ''}
                    </div>
                    <button class="delete-file opacity-0 group-hover:opacity-100 hover:opacity-100 text-red-600 hover:text-red-800 p-1" data-path="${node.path}" title="Delete file">
                        <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"/>
                        </svg>
                    </button>
                </div>
            `;
            
            const fileDiv = div.querySelector('.file-item');
            fileDiv.classList.add('group'); // For hover effects
            treeContainer.appendChild(div);
        }
    }
    
    // Generate and render dynamic tree
    const fileTreeData = generateFileTreeData();
    fileTreeData.forEach(node => renderNode(node));
    
    // Add event listeners
    treeContainer.addEventListener('click', handleTreeClick);
}

// Handle tree clicks
async function handleTreeClick(event) {
    const deleteButton = event.target.closest('.delete-file');
    const folderToggle = event.target.closest('.folder-toggle');
    const fileItem = event.target.closest('.file-item');
    
    if (deleteButton) {
        event.stopPropagation();
        const path = deleteButton.dataset.path;
        workspaceManager.deleteFile(path);
    } else if (folderToggle) {
        const path = folderToggle.dataset.path;
        const state = workspaceManager.getState();
        if (state) {
            if (state.expandedFolders.has(path)) {
                state.expandedFolders.delete(path);
            } else {
                state.expandedFolders.add(path);
            }
            workspaceManager.saveState(workspaceManager.currentContextId);
            renderFileTree();
        }
    } else if (fileItem) {
        const path = fileItem.dataset.path;
        await openFile(path);
    }
}

// Open file in editor
async function openFile(path) {
    if (!workspaceMonacoEditor) return;
    
    const state = workspaceManager.getState();
    if (!state || !state.files[path]) {
        console.error('File not found:', path);
        workspaceMonacoEditor.setValue(`⚠️ File not found: "${path}"`);
        return;
    }
    
    // Update selected file
    state.selectedFile = path;
    workspaceManager.saveState(workspaceManager.currentContextId);
    
    // Show content
    const content = state.files[path];
    workspaceMonacoEditor.setValue(content);
    
    // Update file path label
    updateFilePathLabel(path);
    
    // Refresh tree to show selection
    renderFileTree();
}

// Update file path label
function updateFilePathLabel(path) {
    const filePathElement = document.getElementById('current-file-path');
    if (!filePathElement) return;
    
    if (path) {
        filePathElement.textContent = path;
        filePathElement.className = 'text-xs text-gray-600 font-mono bg-gray-50 px-2 py-1 border border-gray-300 rounded';
    } else {
        filePathElement.textContent = 'No file selected';
        filePathElement.className = 'text-xs text-gray-400 font-mono bg-gray-50 px-2 py-1 border border-gray-300 rounded';
    }
}

// Delete file - wrapper for workspaceManager
async function deleteFile(path) {
    return workspaceManager.deleteFile(path);
}

// Include a file with given path and content - wrapper for workspaceManager
async function includeFile(filePath, content) {
    return workspaceManager.includeFile(filePath, content);
}

// Include predefined content templates
async function includeTemplate(templateName) {
    const templates = {
        'Supabase MCP': {
            path: 'mcps/supabase_mcp.json',
            content: `{
  "name": "supabase-mcp",
  "version": "1.0.0",
  "description": "Model Context Protocol for Supabase integration",
  "tools": [
    {
      "name": "query_database",
      "description": "Execute SQL queries on Supabase database"
    }
  ]
}`
        },
        'Github MCP': {
            path: 'mcps/github_mcp.json',
            content: `{
  "name": "github-mcp",
  "version": "1.0.0",
  "description": "Model Context Protocol for GitHub integration",
  "tools": [
    {
      "name": "create_issue",
      "description": "Create a new GitHub issue"
    }
  ]
}`
        },
        'Python': {
            path: 'guidelines/python_style.md',
            content: `# Python Style Guidelines

## Code Formatting
- Use PEP 8 style guide
- Line length: 88 characters (Black formatter)
- Use type hints for all functions

## Best Practices
- Use meaningful variable names
- Add docstrings to all functions and classes
- Prefer list comprehensions over loops when appropriate`
        },
        'TypeScript': {
            path: 'guidelines/typescript_rules.md',
            content: `# TypeScript Coding Rules

## Type Safety
- Always use strict mode
- No \`any\` type unless absolutely necessary
- Define interfaces for all data structures

## Code Style
- Use Prettier for formatting
- Prefer const over let
- Use arrow functions for callbacks`
        },
        'Researcher': {
            path: 'subagents/researcher.md',
            content: `# Researcher Agent

A specialized subagent for information gathering and analysis.

## Capabilities
- Web search and analysis
- Document research
- Data compilation and synthesis

## Usage
\`\`\`
@researcher find information about [topic]
\`\`\``
        },
        'Memory Manager': {
            path: 'subagents/memory_manager.md',
            content: `# Memory Manager Agent

Handles context and conversation history management.

## Features
- Long-term context preservation
- Conversation summarization
- Knowledge base integration

## Usage
\`\`\`
@memory store this information about [topic]
@memory recall information about [topic]
\`\`\``
        }
    };
    
    const template = templates[templateName];
    if (template) {
        return await includeFile(template.path, template.content);
    } else {
        console.error('Unknown template:', templateName);
        return false;
    }
}

// Expose includeTemplate globally
window.includeTemplate = includeTemplate;

async function createNewFile() {
    const fileName = prompt('Enter file name (with extension):');
    if (!fileName || fileName.trim() === '') {
        return;
    }
    
    const filePath = fileName.trim();
    
    // Create file with default content
    const defaultContent = filePath.endsWith('.md') ? 
        `# ${filePath.replace('.md', '').replace(/[_-]/g, ' ')}\n\nYour content here...` :
        filePath.endsWith('.json') ?
        '{\n  "name": "new-file",\n  "version": "1.0.0"\n}' :
        filePath.endsWith('.yaml') || filePath.endsWith('.yml') ?
        'name: new-file\nversion: 1.0.0\n' :
        '# New file\n\nContent goes here...';
    
    return await includeFile(filePath, defaultContent);
}

// Persist user file state
function persistUserFileState() {
    safeSet('userFiles', JSON.stringify(Array.from(userFiles)));
    safeSet('deletedFiles', JSON.stringify(Array.from(deletedFiles)));
    
    // Save user file contents
    const userFileContents = {};
    userFiles.forEach(path => {
        if (fileContent[path]) {
            userFileContents[path] = fileContent[path];
        }
    });
    safeSet('userFileContents', JSON.stringify(userFileContents));
}

// Initialize file tree system
function initializeFileTree() {
    // Everything is now managed by workspaceManager
    // Just wire up UI event handlers once
    
    // Wire up history buttons
    const prevBtn = document.getElementById('files-prev-btn');
    const nextBtn = document.getElementById('files-next-btn');
    const resetBtn = document.getElementById('files-reset-btn');
    
    if (prevBtn && !prevBtn.hasAttribute('data-initialized')) {
        prevBtn.addEventListener('click', goToPrevious);
        prevBtn.setAttribute('data-initialized', 'true');
    }
    if (nextBtn && !nextBtn.hasAttribute('data-initialized')) {
        nextBtn.addEventListener('click', goToNext);
        nextBtn.setAttribute('data-initialized', 'true');
    }
    if (resetBtn && !resetBtn.hasAttribute('data-initialized')) {
        resetBtn.addEventListener('click', resetFiles);
        resetBtn.setAttribute('data-initialized', 'true');
    }
    
    // Wire up New File button
    const newFileButton = document.getElementById('new-file-button');
    if (newFileButton && !newFileButton.hasAttribute('data-initialized')) {
        newFileButton.addEventListener('click', createNewFile);
        newFileButton.setAttribute('data-initialized', 'true');
    }
    
    // Wire up Quick Action buttons (use delegation to avoid duplicates)
    if (!document.body.hasAttribute('data-qa-initialized')) {
        document.addEventListener('click', async function(e) {
            const button = e.target.closest('.action-button[data-template]');
            if (button) {
                const templateName = button.dataset.template;
                if (templateName) {
                    await includeTemplate(templateName);
                }
            }
        });
        document.body.setAttribute('data-qa-initialized', 'true');
    }
}

// Initialize context UI
function initializeContextUI() {
    const contextSwitcher = document.getElementById('context-switcher');
    const newContextBtn = document.getElementById('new-context-btn');
    const deleteContextBtn = document.getElementById('delete-context-btn');
    
    if (!contextSwitcher) return;
    
    // Handle context switching
    if (!contextSwitcher.hasAttribute('data-initialized')) {
        contextSwitcher.addEventListener('change', function() {
            const newContext = this.value;
            if (newContext && newContext !== workspaceManager.currentContextId) {
                workspaceManager.switchContext(newContext);
            }
        });
        contextSwitcher.setAttribute('data-initialized', 'true');
    }
    
    // Handle new context creation
    if (newContextBtn && !newContextBtn.hasAttribute('data-initialized')) {
        newContextBtn.addEventListener('click', function() {
            const name = prompt('Enter name for new context:');
            if (name && name.trim()) {
                const id = name.toLowerCase().replace(/[^a-z0-9]/g, '-');
                if (workspaceManager.createContext(id, name.trim())) {
                    workspaceManager.switchContext(id);
                } else {
                    alert('Context with this ID already exists');
                }
            }
        });
        newContextBtn.setAttribute('data-initialized', 'true');
    }
    
    // Handle context deletion
    if (deleteContextBtn && !deleteContextBtn.hasAttribute('data-initialized')) {
        deleteContextBtn.addEventListener('click', function() {
            if (workspaceManager.currentContextId === 'default') {
                alert('Cannot delete the default context');
                return;
            }
            
            const contexts = workspaceManager.loadContextsList();
            const currentName = contexts[workspaceManager.currentContextId]?.name || workspaceManager.currentContextId;
            
            if (confirm(`Delete context "${currentName}"? This will remove all associated files.`)) {
                workspaceManager.deleteContext(workspaceManager.currentContextId);
            }
        });
        deleteContextBtn.setAttribute('data-initialized', 'true');
    }
}

// Initialize workspace editor when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Initialize the new WorkspaceManager
    workspaceManager.init();
    
    setTimeout(() => {
        initializeWorkspaceEditor();
        initializeContextUI();
        initializeFileTree();
        
        // Initial render
        workspaceManager.render();
    }, 100);
});
</script>

<!-- Monaco Editor CDN -->
<script src="https://unpkg.com/monaco-editor@0.44.0/min/vs/loader.js"></script>